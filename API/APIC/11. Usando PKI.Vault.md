Asegurando la aplicacion con Vault
=

Al tener desplegado Vault, vamos a aprovecharlo y utilizar su PKI para poder a traves de la CA crear un certificado para el front end.

Reordemos que tenemos Vault desplegado en la maquina virtual
  - direccion IP publica: 169.63.187.221
  - puerto abierto: 8080
  - token: hvs.EN35Jsj6ev2qIynJbfBNaCSl

Agregar PKI a Vault
-

1. Exportar las variables de entorno, como hicimos cuando creamos Vault

``` bash
export VAULT_ADDR='http://169.63.187.221:8080'
export VAULT_TOKEN='hvs.EN35Jsj6ev2qIynJbfBNaCSl'  
```

2. Habilitar PKI y suponemos que usaremos el dominio "miweb.local"

```bash
vault secrets enable pki

vault secrets tune -max-lease-ttl=87600h pki

vault write pki/root/generate/internal \
  common_name="Mi CA Interna" \
  ttl=87600h

vault write pki/config/urls \
  issuing_certificates="$VAULT_ADDR/v1/pki/ca" \
  crl_distribution_points="$VAULT_ADDR/v1/pki/crl"

vault write pki/roles/apache \
  allowed_domains="miweb.local" \
  allow_subdomains=true \
  max_ttl="72h"
```


Crear el certificado para el front end
-

1. El siguiente paso es crear el certificado para nuestro servidor web

```bash
vault write pki/issue/apache \
  common_name="miweb.local" > cert.json
```

2. Debemos extraer los archivos para poder copiarlos al frontend

```bash
jq -r .data.certificate < cert.json > apache-cert.pem
jq -r .data.issuing_ca  < cert.json > apache-ca.pem
jq -r .data.private_key < cert.json > apache-key.pem

scp apache-cert.pem root@10.241.64.69:/etc/pki/tls/certs/
scp apache-ca.pem root@10.241.64.69:/etc/pki/tls/certs/
scp apache-key.pem root@10.241.64.69:/etc/pki/tls/private/
```

Configurar Apache para utilizar HTTPS pero en el puerto 8080
-

1. Debemos crear un archivo en /etc/httpd/conf.d/ssl-8080.conf

```bash
Listen 8080 https

<VirtualHost *:8080>
    ServerName miweb.local

    SSLEngine on
    SSLCertificateFile      /etc/pki/tls/certs/apache-cert.pem
    SSLCertificateKeyFile   /etc/pki/tls/private/apache-key.pem
    SSLCertificateChainFile /etc/pki/tls/certs/apache-ca.pem

    DocumentRoot "/var/www/html"
</VirtualHost>
```

2. Si tenemos el firewall activado, debemos ejecutar estos pasos

```bash
sudo firewall-cmd --permanent --add-port=8080/tcp
sudo firewall-cmd --reload

# Solo si SELinux está activo
sudo dnf install -y policycoreutils-python-utils
sudo semanage port -a -t http_port_t -p tcp 8080
```

3. Reiniciar Apache

```bash
sudo systemctl restart httpd
```

4. Para comprobar el buen funcionamiento, antes hay que agregar en el hosts la direccion miweb.local. Finalmente, usar curl o el browser para probar

```bash
curl -k https://miweb.local:8080
```

Renovacion automatica de certificados
-

La renovacion automatica de certificados se puede realizar unicamente con la version Enterprise, pero al usar la version open source debemos recurrir a tareas manuales que podemos automatizar con cron.

1. Crear el siguiente script en /usr/local/bin/renueva-cert.sh

```bash
#!/bin/bash

VAULT_ADDR="http://169.63.187.221:8080"
VAULT_TOKEN="root"  # ⚠️ Proximo paso.. veremos como usar un usuario que no es el root

# Solicitar nuevo certificado
curl -s --header "X-Vault-Token: $VAULT_TOKEN" \
     --request POST \
     --data '{"common_name": "miweb.local"}' \
     $VAULT_ADDR/v1/pki/issue/apache > /tmp/cert.json

# Verificar que no haya fallado
if ! grep -q '"certificate":' /tmp/cert.json; then
  echo "Error obteniendo certificado desde Vault"
  exit 1
fi

# Guardar nuevas partes
jq -r .data.certificate < /tmp/cert.json > /etc/pki/tls/certs/apache-cert.pem
jq -r .data.issuing_ca  < /tmp/cert.json > /etc/pki/tls/certs/apache-ca.pem
jq -r .data.private_key < /tmp/cert.json > /etc/pki/tls/private/apache-key.pem

# Recargar Apache
systemctl reload httpd
```

2.  Dar permisos de ejecucion

```bash
chmod +x /usr/local/bin/renueva-cert.sh
```

3. Crear entrada en /etc/crontab (o crontab -e) para ejecutar el script todos los Domingos a las 4:00 am 

```bash
0 4 * * 0 root /usr/local/bin/renueva-cert.sh
```

Modificando el entorno y el script para usar menores privilegios
-

1. En el vault vamos a crear una politica y le pondremos nombre Apache

```bash
path "pki/issue/apache" {
  capabilities = ["create", "update"]
}
```

2. Aplicamos la politica

```bash
vault policy write apache-pki apache-pki.hcl
```

3. Creamos un token asociado a la politica

```bash
vault token create -policy="apache-pki" -ttl=720h -renewable=true
```

Deberiamos obtener algo asi como

```bash
Key                  Value
---                  -----
token                s.dY3kEi5AhV8x8v6PpH7b3U4r
token_accessor       ...
token_duration       720h
token_renewable      true
token_policies       ["apache-pki" "default"]
```

4. Copiar el valor del token, como por ejemplo s.dY3kEi5AhV8x8v6PpH7b3U4r

Este token tiene permiso solo para emitir certificados del rol apache en el engine pki.

Copiar el token y modificar el script
-

1. En la maquina front end, crear un archivo con el token

```bash
echo "s.dY3kEi5AhV8x8v6PpH7b3U4r" > /etc/vault_token_apache
chmod 600 /etc/vault_token_apache
```

2. Modificamos el script para usar el token con menos privilegios

```bash
#!/bin/bash

VAULT_ADDR="http://169.63.187.221:8080"
VAULT_TOKEN=$(cat /etc/vault_token_apache)

# Solicitar nuevo certificado
curl -s --header "X-Vault-Token: $VAULT_TOKEN" \
     --request POST \
     --data '{"common_name": "miweb.local"}' \
     $VAULT_ADDR/v1/pki/issue/apache > /tmp/cert.json

# Verificar éxito
if ! grep -q '"certificate":' /tmp/cert.json; then
  echo "Error obteniendo certificado desde Vault"
  exit 1
fi

# Guardar archivos
jq -r .data.certificate < /tmp/cert.json > /etc/pki/tls/certs/apache-cert.pem
jq -r .data.issuing_ca  < /tmp/cert.json > /etc/pki/tls/certs/apache-ca.pem
jq -r .data.private_key < /tmp/cert.json > /etc/pki/tls/private/apache-key.pem

# Recargar Apache
systemctl reload httpd
```


