# Asegurando los Secretos

Durante el desarrollo del workshop hemos visto como crear Client Id y Client Secret, hemos visto como conectarnos por la API a la base de datos... pero tambien, hemos visto como dejar esas credenciales en archivos php o html. 

Claramente no es una buena practica, dejarlos con tan simple acceso. Por eso, vamos a hacer uso de Hashicorp Vault que es una boveda para guardar secretos.

En Vault vamos a generar estos secretos y vamos a consultarlos, cuando se requiera.

Para poder agregar este contenido, vamos a estar agregando una maquina virtual para poder instalar Hashicorp Vault.

---

Desplegar Vault
=


```bash
#!/bin/bash
# Instala y configura HashiCorp Vault (Open Source) en RHEL 9 (VM4)

# Instalar dependencias
sudo dnf install -y unzip curl jq

# crear el repo
sudo tee /etc/yum.repos.d/hashicorp.repo <<EOF
[hashicorp]
name=HashiCorp Stable - RHEL 9
baseurl=https://rpm.releases.hashicorp.com/RHEL/9/x86_64/stable
enabled=1
gpgcheck=1
gpgkey=https://rpm.releases.hashicorp.com/gpg
EOF

# instalar Vault
sudo dnf clean all
sudo dnf install -y vault

echo $PATH
export PATH=$PATH:/usr/bin

# Crear usuario y carpeta de datos
sudo useradd --system --home /etc/vault.d --shell /bin/false vault
sudo mkdir -p /etc/vault.d /var/lib/vault
sudo chown -R vault:vault /etc/vault.d /var/lib/vault

# Crear archivo de configuración
cat <<EOF | sudo tee /etc/vault.d/vault.hcl
listener "tcp" {
  address     = "0.0.0.0:8080"
  tls_disable = 1
}

storage "file" {
  path = "/var/lib/vault"
}

ui = true
disable_mlock = true
EOF

# Crear servicio systemd
sudo tee /etc/systemd/system/vault.service <<EOF
[Unit]
Description=HashiCorp Vault - Official
After=network-online.target
Wants=network-online.target

[Service]
User=vault
Group=vault
ExecStart=/usr/bin/vault server -config=/etc/vault.d/vault.hcl
ExecReload=/bin/kill -HUP \$MAINPID
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF


# Habilitar y arrancar
sudo systemctl daemon-reexec
sudo systemctl enable --now vault
sudo systemctl status vault


```

---

Inicializar Vault
=

1) Inicializa Vault

```bash

export VAULT_ADDR="http://169.63.187.221:8080"
vault status
vault operator init -key-shares=1 -key-threshold=1 > /root/vault_init.txt
```
2) Guardamos unseal key y el root token

```bash
VAULT_UNSEAL_KEY=$(grep 'Unseal Key 1:' /root/vault_init.txt | awk '{print $NF}')
VAULT_TOKEN=$(grep 'Initial Root Token:' /root/vault_init.txt | awk '{print $NF}')

echo $VAULT_UNSEAL_KEY
echo $VAULT_TOKEN
```
4) desbloqueamos Vault

```bash
vault operator unseal $(grep 'Unseal Key 1:' /root/vault_init.txt | awk '{print $NF}')
```
o usamos

```bash
vault operator unseal $VAULT_UNSEAL_KEY
```

5) Nos logueamos con el usuario root (suponemos que el VAULT TOKEN es hvs.EN35J...)

```bash


vault login hvs.EN35Jsj6ev2qIynJbfBNaCSl

export VAULT_TOKEN=hvs.EN35Jsj6ev2qIynJbfBNaCSl

vault token lookup
vault secrets list

vault secrets enable -path=workshop kv-v2


```

4) Creamos los dos secretos

```bash
vault kv put workshop/db usuario=apiuser password=apipass
vault kv put workshop/ibmapi client_id=a3abc43608c0de849addfdc338589e4c client_secret=98ec18754fc0742e90a2f03176aa75e2

vault kv get workshop/db
vault kv get workshop/ibmapi

```

---

Modificar el Acceso a la Base de datos
=

1) Probar el acceso al Vault desde la VM2
```bash
export VAULT_TOKEN="hvs.EN35Jsj6ev2qIynJbfBNaCSl"

curl \
  --header "X-Vault-Token: $VAULT_TOKEN" \
  http://169.63.187.221:8080/v1/workshop/data/db

```

2) En el PHP de la VM2 debemos modificar la forma en que se accede a la base de datos

```bash
$vault = curl_init();
curl_setopt($vault, CURLOPT_URL, "http://169.63.187.221:8080/v1/workshop/data/db");
curl_setopt($vault, CURLOPT_RETURNTRANSFER, true);
curl_setopt($vault, CURLOPT_HTTPHEADER, ["X-Vault-Token: TU_TOKEN_AQUI"]);
$response = curl_exec($vault);
curl_close($vault);

$data = json_decode($response, true);
$user = $data["data"]["usuario"];
$pass = $data["data"]["password"];

$mysqli = new mysqli("10.241.64.68", $user, $pass, "clientes_db", 8080);
```

Modificar el acceso desde la aplicacion
=
1) Primero validamos la conectividad desde la VM1 al Vault

```bash
curl \
  --header "X-Vault-Token: $VAULT_TOKEN" \
  http://169.63.187.221:8080/v1/workshop/data/ibmapi

```

1) En el html de la VM1 debemos modificar como acceder al client Id y al Client Secret  
```bash
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Consulta de Cliente</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #resultado { margin-top: 10px; color: #333; }
    #resultado.error { color: red; }
  </style>
</head>
<body>
  <h1>Consulta de Cliente</h1>
  <input type="number" id="idCliente" placeholder="ID cliente">
  <button id="buscarBtn">Buscar</button>
  <button id="todosBtn">Todos</button>
  <div id="resultado"></div>

  <script>
  document.getElementById('buscarBtn').addEventListener('click', buscar);
  document.getElementById('todosBtn').addEventListener('click', traerTodos);

  async function obtenerCredenciales() {
    const response = await fetch("http://169.63.187.221:8080/v1/workshop/data/ibmapi", {
      headers: {
        "X-Vault-Token": "TU_TOKEN_AQUI"
      }
    });
    const json = await response.json();
    return {
      id: json.data.data.client_id,
      secret: json.data.data.client_secret
    };
  }

  async function buscar() {
    const id = document.getElementById('idCliente').value;
    const out = document.getElementById('resultado');
    out.textContent = 'Buscando...';
    try {
      const res = await fetch(`/api_proxy/clientes.php?id=${id}`);
      const text = await res.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch(e) {
        out.textContent = 'Respuesta no válida JSON';
        return;
      }
      if (!res.ok || data.error) {
        out.textContent = data.error;
        out.classList.add('error');
      } else {
        out.classList.remove('error');
        if (data.Nombre && data.Direccion && data.Pais) {
          out.innerHTML =
            `Nombre: ${data.Nombre}<br>Dirección: ${data.Direccion}<br>País: ${data.Pais}`;
        } else {
          out.textContent = "Cliente no encontrado";
          out.classList.add('error');
        }
      }
    } catch(e) {
      out.textContent = 'Error conexión API';
    }
  }

  async function traerTodos() {
    const out = document.getElementById('resultado');
    out.textContent = 'Buscando todos los clientes...';
    try {
      const cred = await obtenerCredenciales();
      const res = await fetch(`/api_proxy/todos_clientes.php`, {
        method: 'GET',
        headers: {
          'X-IBM-Client-Id': cred.id,
          'X-IBM-Client-Secret': cred.secret
        }
      });
      const text = await res.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch(e) {
        out.textContent = 'Respuesta no válida JSON';
        return;
      }
      if (!res.ok || data.error) {
        out.textContent = data.error;
        out.classList.add('error');
      } else {
        out.classList.remove('error');
        out.innerHTML = '<h2>Clientes:</h2>' +
          data.map(c =>
            `ID: ${c.IdCliente}, Nombre: ${c.Nombre}, Dirección: ${c.Direccion}, País: ${c.Pais}`
          ).join('<br>');
      }
    } catch(e) {
      out.textContent = 'Error conexión API';
    }
  }
  </script>
</body>
</html>

```



