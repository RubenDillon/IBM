# Asegurando los Secretos

Durante el desarrollo del workshop hemos visto como crear Client Id y Client Secret, hemos visto como conectarnos por la API a la base de datos... pero tambien, hemos visto como dejar esas credenciales en archivos php o html. 

Claramente no es una buena practica, dejarlos con tan simple acceso. Por eso, vamos a hacer uso de Hashicorp Vault que es una boveda para guardar secretos.

En Vault vamos a generar estos secretos y vamos a consultarlos, cuando se requiera.

Para poder agregar este contenido, vamos a estar agregando una maquina virtual para poder instalar Hashicorp Vault.

---

Desplegar Vault
=


```bash
#!/bin/bash
# Instala y configura HashiCorp Vault (Open Source) en RHEL 9 (VM4)

# Instalar dependencias
sudo dnf install -y unzip curl jq

# crear el repo
sudo tee /etc/yum.repos.d/hashicorp.repo <<EOF
[hashicorp]
name=HashiCorp Stable - RHEL 9
baseurl=https://rpm.releases.hashicorp.com/RHEL/9/x86_64/stable
enabled=1
gpgcheck=1
gpgkey=https://rpm.releases.hashicorp.com/gpg
EOF

# instalar Vault
sudo dnf clean all
sudo dnf install -y vault

echo $PATH
export PATH=$PATH:/usr/bin

# Crear usuario y carpeta de datos
sudo useradd --system --home /etc/vault.d --shell /bin/false vault
sudo mkdir -p /etc/vault.d /var/lib/vault
sudo chown -R vault:vault /etc/vault.d /var/lib/vault

# Crear archivo de configuraciÃ³n
cat <<EOF | sudo tee /etc/vault.d/vault.hcl
listener "tcp" {
  address     = "0.0.0.0:8080"
  tls_disable = 1
}

storage "file" {
  path = "/var/lib/vault"
}

ui = true
disable_mlock = true
EOF

# Crear servicio systemd
sudo tee /etc/systemd/system/vault.service <<EOF
[Unit]
Description=HashiCorp Vault - Official
After=network-online.target
Wants=network-online.target

[Service]
User=vault
Group=vault
ExecStart=/usr/bin/vault server -config=/etc/vault.d/vault.hcl
ExecReload=/bin/kill -HUP \$MAINPID
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF


# Habilitar y arrancar
sudo systemctl daemon-reexec
sudo systemctl enable --now vault
sudo systemctl status vault


```

---

Inicializar Vault
=

1) Inicializa Vault

```bash

export VAULT_ADDR="http://169.63.187.221:8080"
vault status
vault operator init -key-shares=1 -key-threshold=1 > /root/vault_init.txt
```
2) Guardamos unseal key y el root token

```bash
VAULT_UNSEAL_KEY=$(grep 'Unseal Key 1:' /root/vault_init.txt | awk '{print $NF}')
VAULT_TOKEN=$(grep 'Initial Root Token:' /root/vault_init.txt | awk '{print $NF}')

echo $VAULT_UNSEAL_KEY
echo $VAULT_TOKEN
```
4) desbloqueamos Vault

```bash
vault operator unseal $(grep 'Unseal Key 1:' /root/vault_init.txt | awk '{print $NF}')
```
o usamos

```bash
vault operator unseal $VAULT_UNSEAL_KEY
```

5) Nos logueamos con el usuario root (suponemos que el VAULT TOKEN es hvs.EN35J...)

```bash


vault login hvs.EN35Jsj6ev2qIynJbfBNaCSl

export VAULT_TOKEN=hvs.EN35Jsj6ev2qIynJbfBNaCSl

vault token lookup
vault secrets list

vault secrets enable -path=workshop kv-v2


```

4) Creamos los dos secretos

```bash
vault kv put workshop/db usuario=apiuser password=apipass
vault kv put workshop/ibmapi client_id=a3abc43608c0de849addfdc338589e4c client_secret=98ec18754fc0742e90a2f03176aa75e2

vault kv get workshop/db
vault kv get workshop/ibmapi

```

---

Modificar el Acceso a la Base de datos
=

1) Probar el acceso al Vault desde la VM2
```bash
export VAULT_TOKEN="hvs.EN35Jsj6ev2qIynJbfBNaCSl"

curl \
  --header "X-Vault-Token: $VAULT_TOKEN" \
  http://169.63.187.221:8080/v1/workshop/data/db

```

2) En el PHP de la VM2 debemos modificar la forma en que se accede a la base de datos

```bash
$vault = curl_init();
curl_setopt($vault, CURLOPT_URL, "http://169.63.187.221:8080/v1/workshop/data/db");
curl_setopt($vault, CURLOPT_RETURNTRANSFER, true);
curl_setopt($vault, CURLOPT_HTTPHEADER, ["X-Vault-Token: TU_TOKEN_AQUI"]);
$response = curl_exec($vault);
curl_close($vault);

$data = json_decode($response, true);
$user = $data["data"]["usuario"];
$pass = $data["data"]["password"];

$mysqli = new mysqli("10.241.64.68", $user, $pass, "clientes_db", 8080);
```

Modificar el acceso desde la aplicacion
=

Aqui surge un dilema importante y es como accedemos a client_id y a client_secret? 

Si las dejamos como las habiamos expuesto en el index.html, es muy inseguro porque estamos exponiendo informacion que no deberiamos.

Por ello, vamos a tener que cambiar el comportamiento de la aplicacion, para que quede mas segura. Eso, nos llevara a mover client_id y client_secret, a la API. De ese modo, aseguramos las credenciales contra Vault.




1) Primero validamos la conectividad desde la VM1 al Vault

```bash

export VAULT_TOKEN="hvs.EN35Jsj6ev2qIynJbfBNaCSl"

curl \
  --header "X-Vault-Token: $VAULT_TOKEN" \
  http://169.63.187.221:8080/v1/workshop/data/ibmapi

```





