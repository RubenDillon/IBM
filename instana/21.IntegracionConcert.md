Integracion con IBM Concert
=

En este apartado, vamos a estar integrando Instana con IBM Concert, para lo que es Vulnerabilidades.

La integracion con IBM Concert se da en doble sentido, desde la Interfaz de Concert como desde la interfaz de Instana. Finalmente, el agnete de Instana tiene que activar el sensor CVE.

En nuestro caso, aprovechamos el uso de los trials de IBM Instana y de IBM Concert.


Integracion de ambas plataformas
-

**Step 1**: Generate an Instana API token
From the navigation menu in the Instana UI, click Settings > Security & Access > API Tokens.

  - Click New API Token.

  - Enter a unique name for your API token, such as Concert.

  - For the Instana-Concert integration, the default token permissions are sufficient as Concert uses read-only APIs.


After the API token generates, copy it to a secure location. You need it when you create the connection in Concert.


**Step 2**: Establish a connection with Instana
In the Concert UI, establish a connection with Instana by completing the following steps:

  - From the Concert navigation menu, go to Administration > Integrations.

  - On the Connections tab, click Create connection.

  - Select IBM Instana Observability. Use the search bar or scroll to find.

  - On the Create IBM Instana Observability connection screen, enter a name and description for the connection.

  - In the Endpoint field, enter the host URL of the Instana application endpoint in one of the following formats.

  - We will put our tenant  https://myname-instana.instana.io

  - Enter the Instana API token that you generated in step 1.

  - Click Validate connection.

  - After the connection validates, click Create.


**Step 3**: Create a data ingestion job in Concert
To create an ingestion job to pull application and environment data from Instana to Concert, complete the following steps:

  - In the Concert UI, click Administration > Integrations.

  - On the Ingestion jobs tab, click Create ingestion job.

  - Enter a name and description for the ingestion job.

  - For Connection type, select Instana.

  - For Connection, select the name of the connection that you created in the previous step.

  - Select the Target environment that is defined in your Concert inventory.

  - Click Create. The new ingestion job appears in the list.

  - Click the overflow menu for the ingestion job you created and select Run now to start ingesting data from Instana.

**Step 4**: Generate a Concert API key
In the Concert UI, click Profile > API key.

  - Click Generate API key.

  - After the API key generates, copy it to a secure location. You need it when you configure the CVE sensor in Instana.


**Step 5**: Configure the CVE sensor in Instana
The Instana CVE sensor collects vulnerability data from Concert so you can view it in Instana.

  - Enable the CVE sensor by updating the agent configuration file /opt/instana/agent/etc/instana/configuration.yaml, as shown in the following example:

<img width="1037" height="167" alt="image" src="https://github.com/user-attachments/assets/f6a703e2-0617-476d-b09e-9538ef1a6675" />

Our current Environment is like this
  - Instana: https://yellow-tanganyika0z3tc.instana.io/
  - Concert: https://71538.jp-tok-2.concert.saas.ibm.com/#/home?instance_id=20250802-2204-1075-61d7-381f41e7b94c


Instalación de herramienta para definicion de SBOM
-

Para instalar Syft

```
curl -sSfL https://get.anchore.io/syft | sudo sh -s -- -b /usr/local/bin
```

Ejecutar Syft contra una imagen (Contenedor)

```
syft registry.gitlab.com/quote-of-the-day/qotd-web:v5.1.0 -o cyclonedx-json > web.syft.json
```

Ir a Dimension, Luego Software composition

<img width="1718" height="874" alt="image" src="https://github.com/user-attachments/assets/6ad992f7-11d4-462e-88bf-dbf240828ffe" />

<img width="653" height="660" alt="image" src="https://github.com/user-attachments/assets/7d4fa120-8980-4821-a704-e9c70e5ba15e" />

Event Log

<img width="1703" height="858" alt="image" src="https://github.com/user-attachments/assets/c376511d-00d3-48c5-a3ad-bbceec9b8523" />

<img width="1703" height="858" alt="image" src="https://github.com/user-attachments/assets/1ed15571-2d36-4a46-bdd8-f2da7a910c35" />




Instalacion de herramientas de busqueda de vulnerabilidades
-

Para instalar Grype como herramienta de busqueda de Vulnerabilidades

```
curl -sS https://webi.sh/grype | sh; source ~/.config/envman/PATH.env

```
Usar la herramienta para analizar en una imagen (contenedor) de quote of the day 

```
grype registry.gitlab.com/quote-of-the-day/qotd-web:v5.1.0 -o cyclonedx-json > web.json
```

Then upload this image to Concert

<img width="1713" height="865" alt="image" src="https://github.com/user-attachments/assets/1174bcd3-fdaf-4640-83c2-ba372eb9df9a" />

<img width="649" height="640" alt="image" src="https://github.com/user-attachments/assets/893bc4cf-4967-43e1-bafb-92a676d3ae6b" />

Then go to Administration, Event Logs...

<img width="1718" height="874" alt="image" src="https://github.com/user-attachments/assets/b5385fb5-c2e8-451c-aad3-c39eb64827ee" />

<img width="1718" height="874" alt="image" src="https://github.com/user-attachments/assets/ce27f8e0-8b3a-4210-ad6a-29cae72fa8ff" />



Uso de herramientas para analizar Maquinas virtuales 
=

Para el caso de virtual machines, vamos a usar Trivy para la busqueda de vulnerabilidades. Seguiremos usando syft para generacion del BOM. 

Instalamos Trivy

```

curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin v0.52.2

```

Generamos los JSON

```
/usr/local/bin/trivy fs / --scanners vuln --format json --output vm_cut_triv.json

```

Para subir el resultado de Trivy, deberiamos generar la conversion al formato que Concert espera recibir. Para ello, utilizamos este codigo python. Creamos un archivo llamado conversion.py 

NOTA: Este archivo de conversion utiliza el vm_scan_concert_sample.csv como modelo ejemplo que Concert espera cuando se envia un scan de Vulnerabilidades utilizando una herramienta que no esta listada. En el momento que escribo este tutorial, ese archivo se encuentra en https://github.com/IBM/Concert/blob/main/use-case-data-files/1.0.3/vulnerabilities/vm_scan/vm_scan_concert_sample.csv 

Algo particular que tambien ocurre, es que si el CVE no tiene un 4 al comienzo de su ultimo identificador, no es aceptado y devuelve error. Por eso, fuerzo el 4 en la ultima parte del CVE 

```
import json
import csv
import sys

# Archivos
json_file = "vm_cut_triv.json"
output_csv_file = "output.csv"

# --- Leer parámetros desde línea de comandos ---
if len(sys.argv) != 3:
    print("Uso: python3 convertir.py <Host IPAddress> <Host Name>")
    sys.exit(1)

host_ip = sys.argv[1]
host_name = sys.argv[2]

# 1. Definir columnas en el orden deseado
headers = [
    "CVE",
    "Host IPAddress",
    "Host Name",
    "Package",
    "Package Version",
    "Package Path",
    "severity",
    "Score",
    "hasFix",
    "Fixed Version",
    "Description"
]

# 2. Leer JSON de Trivy
with open(json_file, "r", encoding="utf-8") as f:
    data = json.load(f)

rows = []

# 3. Recorrer vulnerabilidades y mapear usando nombres EXACTOS
for result in data.get("Results", []):
    for vuln in result.get("Vulnerabilities", []):
        row = {col: "" for col in headers}

        # --- CVE con "4" añadido en la última parte ---
        vuln_id = vuln.get("VulnerabilityID", "")
        if vuln_id.startswith("CVE-"):
            parts = vuln_id.split("-")
            if len(parts) == 3 and parts[2].isdigit():
                parts[2] = "4" + parts[2].lstrip("0")
                vuln_id = "-".join(parts)
        row["CVE"] = vuln_id

        row["Host IPAddress"] = host_ip
        row["Host Name"] = host_name
        row["Package"] = vuln.get("PkgName", "")
        row["Package Version"] = vuln.get("InstalledVersion", "")
        row["Package Path"] = vuln.get("PkgIdentifier", {}).get("PURL", "")
        row["severity"] = vuln.get("Severity", "")

        score = ""
        if "CVSS" in vuln:
            if "nvd" in vuln["CVSS"] and "V3Score" in vuln["CVSS"]["nvd"]:
                score = vuln["CVSS"]["nvd"]["V3Score"]
            elif "redhat" in vuln["CVSS"] and "V3Score" in vuln["CVSS"]["redhat"]:
                score = vuln["CVSS"]["redhat"]["V3Score"]
        row["Score"] = score

        row["hasFix"] = "N"   # siempre N
        row["Fixed Version"] = vuln.get("FixedVersion", "")

        # ✅ Usar la Description real, limpiando saltos de línea
        row["Description"] = vuln.get("Description", "").replace("\n", " ").replace("\r", " ")

        rows.append(row)

# 4. Guardar CSV final (sin comillas extra)
with open(output_csv_file, "w", newline='', encoding="utf-8") as f:
    writer = csv.DictWriter(f, fieldnames=headers, quoting=csv.QUOTE_MINIMAL)
    writer.writeheader()
    writer.writerows(rows)

print(f"✅ Conversión completada: {output_csv_file} con {len(rows)} registros")

```

Ejecutamos el programa

```

python3 conversion.py hostIP HostNAME

```



Y luego, subimos el resultado

```

curl -X POST "https://71538.jp-tok-2.concert.saas.ibm.com/ingestion/api/v1/upload_files" \
  -H "accept: application/json" \
  -H "Content-Type: multipart/form-data" \
  -H "InstanceID: 20250802-2204-1075-61d7-381f41e7b94c" \
  -H "Authorization: C_API_KEY cnViZW4uZGlsbG9uQGlibS5jb206MDZhMDk5YWEtMDg2NS00ZGRiLWFmYjUtOWQyZjc1ZWNiMDAw" \
  -F "data_type=vm_scan" \
  -F "filename=@output.csv;filename=output.csv" \
  -F 'metadata={"scanner_name":"Other"}'

```

y deberiamos ver una respuesta 202 Acceptance


y en Event Log... deberiamos ver el upload


Documentacion utilizada

- https://www.ibm.com/docs/en/concert?topic=dimension-supported-vulnerability-scan-formats
- https://trivy.dev/latest/docs/configuration/reporting/
- https://webinstall.dev/grype/
- 
